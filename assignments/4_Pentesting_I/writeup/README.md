# Writeup 3 - Operational Security and Social Engineering

Name: Ashan Panduwawala
Section: 0101

I pledge on my honor that I have not given or received any unauthorized assistance on this assignment or examination.

Digital acknowledgement: Ashan Panduwawala

## Assignment Writeup

### Part 1 (40 pts)
CMSC389R-{d1gging_f0r_flag5_thr0ugh_1njec7ion}.
Initially, I was trying to figure out how to break into to the linux server and so, like many people do, I searched it up. This led me to methods such as pinging, and netcat, but ultimately they weren’t much of use. It was not until I read the slides closely that I found the Shellshock method.
When I nc'd into the website, I got the prompt "Give me a domain or IP to look up." After seeing the Shellshock Unix vulnerability and seeing that the remote server was using Linux, I decided to use a command injection to see if I can get access to the shell. First, I entered the command ‘1; ls.’ After all of the dns lookup information was printed, a line containing all of the directories of the server was also there. Since the Shellshock worked, I tried to gain access to the shell. I looked up various ways to get into the shell, and after entering ‘1;bin/sh’, I got in. Next, I tried looking inside each directory using ls to find the flag. Going into the home directory, I found the file called "flag.txt." After calling cat on the file, I found the flag above. 
There are many ways to prevent command injection. One of them is testing the input using regular expressions. Using regular expressions, we can take in only valid strings and sort out any suspicious commands such as /\sls/. Another way is to run the server with restricted permissions. This means only allowing specific directories to be accessed on the client-side. However, the most beneficial way is to avoid command line calls altogether. This means not exec’ing to the operating systems when possible. It is best to keep the functionality of the application within the application. Furthermore, there are specific characters that can be used for unix based systems. Some of them are &, && , | , || and ;. These commands allow commands to be chained together, allowing for destructive usage. Similar to above, we can scan for these characters and prevent these commands from going through.
### Part 2 (60 pts)
For this part, I decided to use a class called cmd to implement the shell system. The Cmd library contains the functionality for making your own shell. First I created a class called ShellOne. This class holds the initial shell that has the actions: shell, pull, help, and quit. The pull function requires a string that has a file in a remote directory and a file in a local path in one string. The program will then copy that file into the file in the local path. If it doesn't exist, the file will be created. Help displays usable functions. 'quit' will exit the program. If the user enters “shell,” then a new class is created (called Cmd), which will implement the command lines of UNIX. One of the problems that I encountered was using the same vulnerability as above. By using socket and sending the field ‘s.send(“1;bin/sh\n”),’ I was able to get into the shell however, I was not able to leave it as it has no way of going back and forth between the two. So, as a semi-brute force solution, I treated every command individually and modified global variables if any function depended on previous calls (e.g. cd). One of these variables is ‘curr.’ ‘curr’ holds the current directory which was found through cd calls. Using this, we can call any of the other functions (ls and cat) and get the value we want. This works by using sockets and connecting to the server. The shell will continuously take input and relay the commands to the execute_cmd function. By typing 'exit', the program will exit the interactive shell and return to the original shell. This stub code is running python on version 2.7.15. Some things that could be improved are that there is no need to use the cmd module when you could just use a while loop. 

